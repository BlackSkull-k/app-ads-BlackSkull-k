<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BlackSkull-k Apps - Tetris</title>
<link rel="icon" type="image/png" sizes="32x32" href="images/bskFavicon32x.png">
<link rel="apple-touch-icon" sizes="180x180" href="images/bskFavicon180x.png">
<link rel="manifest" href="/manifest.json">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
/* STILE GENERALE */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(135deg, #2c3e50, #1b2836);
  color: #ecf0f1;
  display: flex;
  flex-direction: column;
}

header img {
  width: 100%;
  max-height: 200px;
  object-fit: cover;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  margin-bottom: 10px;
}

/* Scrollable navbar with arrows */
.navbar-container {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(44, 62, 80, 0.8);
  box-shadow: 0 4px 6px rgba(0,0,0,0.2);
  padding: 10px 0;
}

.navbar {
  display: flex;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  scroll-behavior: smooth;
  padding: 0 30px;
}

.navbar a {
  color: #ecf0f1;
  text-decoration: none;
  padding: 10px 18px;
  margin: 0 8px;
  font-weight: 500;
  border-radius: 20px;
  transition: all 0.3s ease;
  flex: 0 0 auto;
}

.navbar a:hover { background-color: #34495e; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
.navbar a.active { background-color: #0b47a1; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }

/* Arrows */
.nav-arrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  color: #ecf0f1;
  font-size: 20px;
  background: rgba(0,0,0,0.3);
  border-radius: 50%;
  width: 30px;
  height: 30px;
  line-height: 30px;
  text-align: center;
  cursor: pointer;
  user-select: none;
  z-index: 10;
  display: none;
}
.nav-arrow:hover { background: rgba(0,0,0,0.5); }

.nav-left { left: 5px; }
.nav-right { right: 5px; }

main {
  flex: 1;
  max-width: 1000px;
  margin: 20px auto;
  padding: 10px;
}
h2 { margin-bottom: 15px; text-align: center; color: #3498db; }

.content { padding-bottom: 60px; }

/* Bottom bar */
.bottom-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: rgba(44, 62, 80, 0.8);
  color: #f0f0f0;
  text-align: center;
  padding: 10px 0;
  font-size: 14px;
  box-shadow: 0 -2px 5px rgba(0,0,0,0.3);
  z-index: 1000;
}

/* New class for the white card (updated) */
.white-card {
  background: rgba(52, 73, 94, 0.8);
  border-radius: 15px;
  padding: 30px;
  margin-top: 30px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.5); /* Stronger shadow */
  text-align: center;
  border: 2px solid #556b7f; /* Soft border */
}

/* GAME STYLE (updated) */
.tetris-game-container {
    display: flex;
    flex-direction: row; 
    align-items: flex-start;
    justify-content: center;
    gap: 25px;
    flex-wrap: wrap; 
}

.tetris-sidebar {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 200px; 
    min-width: 180px;
}

.tetris-info-panel {
    background: #2c3e50;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    text-align: left;
    border: 1px solid #4a6279;
}
.tetris-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.tetris-controls button {
    background-color: #e67e22;
    color: #fff;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.1s;
    font-weight: 600;
    box-shadow: 0 4px 6px rgba(0,0,0,0.2);
}
.tetris-controls button:hover {
    background-color: #d35400;
    transform: translateY(-2px);
}
.tetris-controls button:active {
    transform: translateY(0);
}
.tetris-info p {
    margin: 5px 0;
    font-weight: 600;
}
#nextPieceCanvas {
    background: #2a2b40;
    border: 2px solid #333;
    border-radius: 8px;
    margin-top: 5px;
}
#tetrisCanvas {
  display: block;
  background: #111;
  border: 3px solid #333;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
  touch-action: none;
  background: linear-gradient(180deg, #1a1b2d, #3c4476); /* New background */
}

/* Style for the new Tetris controls */
.tetris-controls-mobile {
  margin-top: 20px;
  display: grid;
  grid-template-areas: ". up ." "left down right";
  gap: 15px;
  justify-content: center;
}

.tetris-control-btn {
  background: linear-gradient(45deg, #1e2db6, #3498db);
  color: #fff;
  border: none;
  padding: 18px;
  border-radius: 12px;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  width: 60px;
  height: 60px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 28px;
  transition: background 0.3s, transform 0.1s;
}

.tetris-control-btn:hover { background: linear-gradient(45deg, #162090, #297fb8); transform: translateY(-2px); }
.tetris-control-btn:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

#tetrisControl-up { grid-area: up; }
#tetrisControl-left { grid-area: left; }
#tetrisControl-right { grid-area: right; }
#tetrisControl-down { grid-area: down; }


/* Game over overlay */
#tetrisGameOverOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.85);
  color: #fff;
  display: none; 
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 100;
  font-size: 2.2em;
  text-align: center;
  border-radius: 10px;
  animation: fadeIn 0.5s ease-out;
}
#tetrisGameOverOverlay h3 {
    margin-bottom: 10px;
    font-size: 1.2em;
    font-weight: 700;
    color: #e74c3c;
    text-shadow: 2px 2px 4px #000;
}
#tetrisGameOverOverlay button {
  margin-top: 25px;
  background-color: #e74c3c;
  color: #fff;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 0.8em;
  cursor: pointer;
  transition: background-color 0.3s, transform 0.1s;
  box-shadow: 0 4px 6px rgba(0,0,0,0.2);
}
#tetrisGameOverOverlay button:hover {
  background-color: #c0392b;
  transform: translateY(-2px);
}
#tetrisGameOverOverlay button:active {
    transform: translateY(0);
}

/* Keyframes for animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

</style>
</head>
<body>

<header>
  <!-- Aggiunto fetchpriority="high" all'immagine del logo -->
  <img src="images/Logo1.png" alt="BlackSkull-k Logo" fetchpriority="high">
</header>

<div class="navbar-container">
  <div class="nav-arrow nav-left">&#10094;</div>
  <div class="navbar">
    <a href="index.html">Home</a>
    <a href="applications.html">Applications</a>
    <a href="flashgames.html" class="active">Flash Games</a>
    <a href="contacts.html">Contacts</a>
    <a href="affiliate.html">Affiliate Sites</a>
  </div>
  <div class="nav-arrow nav-right">&#10095;</div>
</div>

<main class="content">

  <div class="white-card">
    <div id="tetris-game">
      <h2>Tetris Game</h2>
      <div class="section">
        <!-- Changed class name for clarity -->
        <div class="tetris-game-container" style="position:relative;">
            <canvas id="tetrisCanvas" width="200" height="400"></canvas>
            <div id="tetrisGameOverOverlay">
              <div>Game Over</div>
              <h3>Final Score: <span id="tetrisFinalScoreSpan">0</span></h3>
              <button onclick="restartTetrisGame()">Restart</button>
            </div>
            <div class="tetris-sidebar">
              <div class="tetris-info-panel">
                <h3>Score: <span id="tetrisScore">0</span></h3>
                <p>Lines: <span id="tetrisLines">0</span></p>
                <p>Level: <span id="tetrisLevel">1</span></p>
                <p>Best Score: <span id="tetrisBestScore">0</span></p>
              </div>
              <div class="tetris-info-panel">
                <p>Next Piece:</p>
                <canvas id="nextPieceCanvas" width="80" height="80"></canvas>
              </div>
              <div class="tetris-controls">
                <button id="tetrisStartBtn">Start Game</button>
                <button id="tetrisPauseBtn">Pause</button>
              </div>
            </div>
        </div>

        <div class="tetris-controls-mobile">
          <button id="tetrisControl-up" class="tetris-control-btn">&#x21BB;</button>
          <button id="tetrisControl-left" class="tetris-control-btn">&#9664;</button>
          <button id="tetrisControl-right" class="tetris-control-btn">&#9654;</button>
          <button id="tetrisControl-down" class="tetris-control-btn">&#9660;</button>
        </div>
      </div>
    </div>
  </div>
</main>

<div class="bottom-bar">
    BlackSkull-k ® 2021-2025
</div>

<script>
// Gestione delle frecce della navbar
const nav = document.querySelector('.navbar');
const leftArrow = document.querySelector('.nav-left');
const rightArrow = document.querySelector('.nav-right');
const activeLink = document.querySelector('.navbar a.active');

// Funzione per aggiornare la visibilità delle frecce
function updateArrows() {
  if (nav.scrollWidth > nav.clientWidth) {
    // La freccia sinistra è visibile solo se non siamo all'inizio
    leftArrow.style.display = nav.scrollLeft > 0 ? "block" : "none";
    // La freccia destra è visibile solo se non siamo alla fine
    // Aggiunto un piccolo margine per una verifica più affidabile
    const isAtEnd = Math.abs(nav.scrollLeft + nav.clientWidth - nav.scrollWidth) < 1;
    rightArrow.style.display = isAtEnd ? "none" : "block";
  } else {
    // Nascondi le frecce se non c'è scroll
    leftArrow.style.display = "none";
    rightArrow.style.display = "none";
  }
}

// Funzione per centrare il link attivo
function centerActiveLink() {
  if (activeLink) {
    // Calcola la posizione centrale della navbar
    const scrollPosition = activeLink.offsetLeft - (nav.offsetWidth / 2) + (activeLink.offsetWidth / 2);
    nav.scrollLeft = scrollPosition;
    // Aggiorna le frecce immediatamente dopo il centraggio
    updateArrows();
  }
}

// Event listener per le frecce
leftArrow.addEventListener('click', () => {
  nav.scrollBy({ left: -150, behavior: 'smooth' });
});
rightArrow.addEventListener('click', () => {
  nav.scrollBy({ left: 150, behavior: 'smooth' });
});

// Event listener per l'aggiornamento delle frecce durante lo scroll manuale
nav.addEventListener('scroll', updateArrows);

// Centra il link attivo al caricamento della pagina e al ridimensionamento
window.addEventListener('load', centerActiveLink);
window.addEventListener('resize', centerActiveLink);

// Tetris Game Logic
// =================================================================================
const tetrisCanvas = document.getElementById('tetrisCanvas');
const tetrisCtx = tetrisCanvas.getContext('2d');
const nextPieceCanvas = document.getElementById('nextPieceCanvas');
const nextPieceCtx = nextPieceCanvas.getContext('2d');
const tetrisScoreSpan = document.getElementById('tetrisScore');
const tetrisLinesSpan = document.getElementById('tetrisLines');
const tetrisLevelSpan = document.getElementById('tetrisLevel');
const tetrisBestScoreSpan = document.getElementById('tetrisBestScore');
const tetrisStartBtn = document.getElementById('tetrisStartBtn');
const tetrisPauseBtn = document.getElementById('tetrisPauseBtn');
const tetrisGameOverOverlay = document.getElementById('tetrisGameOverOverlay');
const tetrisFinalScoreSpan = document.getElementById('tetrisFinalScoreSpan');

// Dimensioni del gioco
const tetrisRows = 20;
const tetrisCols = 10;
const tetrisBlockSize = tetrisCanvas.width / tetrisCols;

// Colori dei blocchi
const tetrisColors = [
    '#000', '#2ecc71', '#3498db', '#9b59b6', '#f1c40f', '#e67e22', '#e74c3c', '#c0392b'
];

// Forme dei pezzi (pezzi di Tetris)
const tetrisPieces = [
    // I
    [[0, 1, 0, 0],
    [0, 1, 0, 0],
    [0, 1, 0, 0],
    [0, 1, 0, 0]],

    // J
    [[0, 1, 0],
    [0, 1, 0],
    [1, 1, 0]],

    // L
    [[0, 1, 0],
    [0, 1, 0],
    [0, 1, 1]],

    // O
    [[1, 1],
    [1, 1]],

    // S
    [[0, 1, 1],
    [1, 1, 0],
    [0, 0, 0]],

    // T
    [[0, 0, 0],
    [1, 1, 1],
    [0, 1, 0]],

    // Z
    [[1, 1, 0],
    [0, 1, 1],
    [0, 0, 0]]
];

// Stato del gioco
let tetrisGrid = [];
let tetrisCurrentPiece;
let tetrisNextPiece;
let tetrisScore = 0;
let tetrisLines = 0;
let tetrisLevel = 1;
let tetrisDropCounter = 0;
let tetrisDropInterval = 1000;
let tetrisLastTime = 0;
let tetrisGameRunning = false;
let tetrisPaused = false;
let tetrisBestScore = localStorage.getItem('tetrisBestScore') || 0;

// Funzione per creare la griglia di gioco vuota
function createTetrisGrid() {
    return Array.from({ length: tetrisRows }, () => Array(tetrisCols).fill(0));
}

// Funzione per disegnare un blocco
function drawTetrisBlock(ctx, x, y, colorIndex) {
    if (colorIndex > 0) {
        ctx.fillStyle = tetrisColors[colorIndex];
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 1;
        ctx.fillRect(x, y, tetrisBlockSize, tetrisBlockSize);
        ctx.strokeRect(x, y, tetrisBlockSize, tetrisBlockSize);
    }
}

// Funzione per disegnare la griglia
function drawTetrisGrid() {
    for (let row = 0; row < tetrisRows; row++) {
        for (let col = 0; col < tetrisCols; col++) {
            drawTetrisBlock(tetrisCtx, col * tetrisBlockSize, row * tetrisBlockSize, tetrisGrid[row][col]);
        }
    }
}

// Funzione per disegnare il pezzo corrente
function drawTetrisPiece(piece, ctx) {
    piece.matrix.forEach((row, rowIndex) => {
        row.forEach((value, colIndex) => {
            if (value > 0) {
                drawTetrisBlock(ctx, (piece.pos.x + colIndex) * tetrisBlockSize, (piece.pos.y + rowIndex) * tetrisBlockSize, piece.color);
            }
        });
    });
}

// Funzione per disegnare il prossimo pezzo
function drawTetrisNextPiece() {
    nextPieceCtx.fillStyle = '#2a2b40';
    nextPieceCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    const piece = tetrisNextPiece;
    const pieceSize = nextPieceCanvas.width / piece.matrix[0].length;
    const offsetX = (nextPieceCanvas.width - piece.matrix[0].length * pieceSize) / 2;
    const offsetY = (nextPieceCanvas.height - piece.matrix.length * pieceSize) / 2;

    piece.matrix.forEach((row, rowIndex) => {
        row.forEach((value, colIndex) => {
            if (value > 0) {
                const x = colIndex * pieceSize + offsetX;
                const y = rowIndex * pieceSize + offsetY;
                nextPieceCtx.fillStyle = tetrisColors[piece.color];
                nextPieceCtx.strokeStyle = '#2c3e50';
                nextPieceCtx.lineWidth = 1;
                nextPieceCtx.fillRect(x, y, pieceSize, pieceSize);
                nextPieceCtx.strokeRect(x, y, pieceSize, pieceSize);
            }
        });
    });
}

// Funzione per ottenere un pezzo casuale
function getTetrisRandomPiece() {
    const randomIndex = Math.floor(Math.random() * tetrisPieces.length);
    const matrix = tetrisPieces[randomIndex];
    const color = randomIndex + 1;
    return {
        matrix,
        color,
        pos: { x: Math.floor(tetrisCols / 2) - Math.floor(matrix[0].length / 2), y: 0 }
    };
}

// Funzione per verificare le collisioni
function tetrisCollide(grid, piece) {
    const matrix = piece.matrix;
    for (let row = 0; row < matrix.length; row++) {
        for (let col = 0; col < matrix[0].length; col++) {
            if (matrix[row][col] > 0) {
                const newRow = piece.pos.y + row;
                const newCol = piece.pos.x + col;
                if (newCol < 0 || newCol >= tetrisCols || newRow >= tetrisRows || (grid[newRow] && grid[newRow][newCol] > 0)) {
                    return true;
                }
            }
        }
    }
    return false;
}

// Funzione per unire il pezzo alla griglia
function tetrisMerge(grid, piece) {
    piece.matrix.forEach((row, rowIndex) => {
        row.forEach((value, colIndex) => {
            if (value > 0) {
                grid[piece.pos.y + rowIndex][piece.pos.x + colIndex] = piece.color;
            }
        });
    });
}

// Funzione per ruotare una matrice
function tetrisRotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) {
        matrix.forEach(row => row.reverse());
    } else {
        matrix.reverse();
    }
}

// Funzione per ruotare il pezzo
function tetrisRotatePiece() {
    if (!tetrisGameRunning || tetrisPaused) return;
    const pos = tetrisCurrentPiece.pos.x;
    let offset = 1;
    tetrisRotate(tetrisCurrentPiece.matrix, 1);

    while (tetrisCollide(tetrisGrid, tetrisCurrentPiece)) {
        tetrisCurrentPiece.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > tetrisCurrentPiece.matrix[0].length) {
            tetrisRotate(tetrisCurrentPiece.matrix, -1);
            tetrisCurrentPiece.pos.x = pos;
            return;
        }
    }
}

// Funzione per muovere il pezzo
function tetrisMovePiece(dir, y) {
    if (!tetrisGameRunning || tetrisPaused) return;
    tetrisCurrentPiece.pos.x += dir;
    if (tetrisCollide(tetrisGrid, tetrisCurrentPiece)) {
        tetrisCurrentPiece.pos.x -= dir;
    }
    if (y > 0) {
        tetrisCurrentPiece.pos.y += y;
        if (tetrisCollide(tetrisGrid, tetrisCurrentPiece)) {
            tetrisCurrentPiece.pos.y -= y;
            tetrisMerge(tetrisGrid, tetrisCurrentPiece);
            tetrisResetPiece();
            tetrisSweepLines();
            return true;
        }
    }
    return false;
}

// Funzione per resettare il pezzo corrente
function tetrisResetPiece() {
    tetrisCurrentPiece = tetrisNextPiece;
    tetrisNextPiece = getTetrisRandomPiece();
    drawTetrisNextPiece();
    tetrisCurrentPiece.pos.y = 0;
    tetrisCurrentPiece.pos.x = Math.floor(tetrisCols / 2) - Math.floor(tetrisCurrentPiece.matrix[0].length / 2);

    if (tetrisCollide(tetrisGrid, tetrisCurrentPiece)) {
        tetrisGameOver();
    }
}

// Funzione per eliminare le righe complete
function tetrisSweepLines() {
    let linesCleared = 0;
    for (let row = tetrisRows - 1; row >= 0; ) {
        if (tetrisGrid[row].every(value => value > 0)) {
            tetrisGrid.splice(row, 1);
            tetrisGrid.unshift(Array(tetrisCols).fill(0));
            linesCleared++;
            tetrisLines++;
        } else {
            row--;
        }
    }

    if (linesCleared > 0) {
        tetrisScore += linesCleared * 100;
        tetrisLevel = Math.floor(tetrisLines / 10) + 1;
        tetrisDropInterval = 1000 / tetrisLevel;
        updateTetrisScore();
    }
}

// Funzione per aggiornare il punteggio
function updateTetrisScore() {
    tetrisScoreSpan.textContent = tetrisScore;
    tetrisLinesSpan.textContent = tetrisLines;
    tetrisLevelSpan.textContent = tetrisLevel;
    tetrisBestScoreSpan.textContent = tetrisBestScore;
}

// Funzione per il game over
function tetrisGameOver() {
    tetrisGameRunning = false;
    tetrisFinalScoreSpan.textContent = tetrisScore;
    tetrisGameOverOverlay.style.display = 'flex';
    if (tetrisScore > tetrisBestScore) {
        tetrisBestScore = tetrisScore;
        localStorage.setItem('tetrisBestScore', tetrisBestScore);
        tetrisBestScoreSpan.textContent = tetrisBestScore;
    }
}

// Funzione di gioco principale (game loop)
function tetrisLoop(time = 0) {
    if (!tetrisGameRunning || tetrisPaused) return;

    const deltaTime = time - tetrisLastTime;
    tetrisLastTime = time;

    tetrisDropCounter += deltaTime;
    if (tetrisDropCounter > tetrisDropInterval) {
        tetrisMovePiece(0, 1);
        tetrisDropCounter = 0;
    }

    // Pulisci il canvas e ridisegna tutto
    tetrisCtx.fillStyle = '#000';
    tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
    tetrisCtx.fillStyle = '#1a1b2d';
    tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
    
    // Disegna la griglia e il pezzo corrente
    drawTetrisGrid();
    drawTetrisPiece(tetrisCurrentPiece, tetrisCtx);

    requestAnimationFrame(tetrisLoop);
}

// Funzione per riavviare il gioco
function restartTetrisGame() {
    tetrisGameOverOverlay.style.display = 'none';
    tetrisStartBtn.click();
}

// Event listeners
tetrisStartBtn.addEventListener('click', () => {
    if (tetrisGameRunning) {
        // Se il gioco è già in corso, lo resetta
        tetrisGameRunning = false;
        tetrisCtx.fillStyle = '#000';
        tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
    }
    tetrisGameRunning = true;
    tetrisPaused = false;
    tetrisGrid = createTetrisGrid();
    tetrisScore = 0;
    tetrisLines = 0;
    tetrisLevel = 1;
    tetrisDropInterval = 1000;
    updateTetrisScore();
    tetrisCurrentPiece = getTetrisRandomPiece();
    tetrisNextPiece = getTetrisRandomPiece();
    drawTetrisNextPiece();
    tetrisStartBtn.textContent = "Restart Game";
    tetrisPauseBtn.textContent = "Pause";
    tetrisLoop();
});

// Pause/Resume button
tetrisPauseBtn.addEventListener('click', () => {
    if (tetrisGameRunning) {
        tetrisPaused = !tetrisPaused;
        tetrisPauseBtn.textContent = tetrisPaused ? "Resume" : "Pause";
        if (!tetrisPaused) {
            tetrisLoop();
        }
    }
});

// Keyboard controls
document.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') {
        tetrisMovePiece(-1, 0);
    } else if (e.key === 'ArrowRight') {
        tetrisMovePiece(1, 0);
    } else if (e.key === 'ArrowDown') {
        tetrisMovePiece(0, 1);
    } else if (e.key === 'ArrowUp') {
        tetrisRotatePiece();
    }
});

// Mobile controls
document.getElementById('tetrisControl-up').addEventListener('click', () => tetrisRotatePiece());
document.getElementById('tetrisControl-left').addEventListener('click', () => tetrisMovePiece(-1, 0));
document.getElementById('tetrisControl-right').addEventListener('click', () => tetrisMovePiece(1, 0));
document.getElementById('tetrisControl-down').addEventListener('click', () => tetrisMovePiece(0, 1));
</script>
  
</body>
</html>
